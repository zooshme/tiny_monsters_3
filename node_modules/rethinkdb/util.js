// Generated by CoffeeScript 1.7.0
var convertPseudotype, deconstructDatum, err, mkAtom, mkErr, mkSeq, pb, recursivelyConvertPseudotype,
  __slice = [].slice;

err = require('./errors');

pb = require('./protobuf');

module.exports.ar = function(fun) {
  return function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length !== fun.length) {
      throw new err.RqlDriverError("Expected " + fun.length + " argument(s) but found " + args.length + ".");
    }
    return fun.apply(this, args);
  };
};

module.exports.varar = function(min, max, fun) {
  return function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (((min != null) && args.length < min) || ((max != null) && args.length > max)) {
      if ((min != null) && (max == null)) {
        throw new err.RqlDriverError("Expected " + min + " or more argument(s) but found " + args.length + ".");
      }
      if ((max != null) && (min == null)) {
        throw new err.RqlDriverError("Expected " + max + " or fewer argument(s) but found " + args.length + ".");
      }
      throw new err.RqlDriverError("Expected between " + min + " and " + max + " argument(s) but found " + args.length + ".");
    }
    return fun.apply(this, args);
  };
};

module.exports.aropt = function(fun) {
  return function() {
    var args, expectedPosArgs, numPosArgs, perhapsOptDict;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    expectedPosArgs = fun.length - 1;
    perhapsOptDict = args[expectedPosArgs];
    if ((perhapsOptDict != null) && (Object.prototype.toString.call(perhapsOptDict) !== '[object Object]')) {
      perhapsOptDict = null;
    }
    numPosArgs = args.length - (perhapsOptDict != null ? 1 : 0);
    if (expectedPosArgs !== numPosArgs) {
      throw new err.RqlDriverError("Expected " + expectedPosArgs + " argument(s) but found " + numPosArgs + ".");
    }
    return fun.apply(this, args);
  };
};

module.exports.toArrayBuffer = function(node_buffer) {
  var arr, i, value, _i, _len;
  arr = new Uint8Array(new ArrayBuffer(node_buffer.length));
  for (i = _i = 0, _len = node_buffer.length; _i < _len; i = ++_i) {
    value = node_buffer[i];
    arr[i] = value;
  }
  return arr.buffer;
};

convertPseudotype = function(obj, opts) {
  var i, _i, _len, _ref, _results;
  switch (obj['$reql_type$']) {
    case 'TIME':
      switch (opts.timeFormat) {
        case 'native':
        case void 0:
          if (obj['epoch_time'] == null) {
            throw new err.RqlDriverError("pseudo-type TIME " + obj + " object missing expected field 'epoch_time'.");
          }
          return new Date(obj['epoch_time'] * 1000);
        case 'raw':
          return obj;
        default:
          throw new err.RqlDriverError("Unknown timeFormat run option " + opts.timeFormat + ".");
      }
      break;
    case 'GROUPED_DATA':
      switch (opts.groupFormat) {
        case 'native':
        case void 0:
          _ref = obj['data'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            i = _ref[_i];
            _results.push({
              group: i[0],
              reduction: i[1]
            });
          }
          return _results;
          break;
        case 'raw':
          return obj;
        default:
          throw new err.RqlDriverError("Unknown groupFormat run option " + opts.groupFormat + ".");
      }
      break;
    default:
      return obj;
  }
};

recursivelyConvertPseudotype = function(obj, opts) {
  var i, key, value, _i, _len;
  if (obj instanceof Array) {
    for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
      value = obj[i];
      obj[i] = recursivelyConvertPseudotype(value, opts);
    }
  } else if (obj instanceof Object) {
    for (key in obj) {
      value = obj[key];
      obj[key] = recursivelyConvertPseudotype(value, opts);
    }
    obj = convertPseudotype(obj, opts);
  }
  return obj;
};

deconstructDatum = function(datum, opts) {
  return pb.DatumTypeSwitch(datum, {
    "R_JSON": (function(_this) {
      return function() {
        var obj;
        obj = JSON.parse(datum.r_str);
        return recursivelyConvertPseudotype(obj, opts);
      };
    })(this),
    "R_NULL": (function(_this) {
      return function() {
        return null;
      };
    })(this),
    "R_BOOL": (function(_this) {
      return function() {
        return datum.r_bool;
      };
    })(this),
    "R_NUM": (function(_this) {
      return function() {
        return datum.r_num;
      };
    })(this),
    "R_STR": (function(_this) {
      return function() {
        return datum.r_str;
      };
    })(this),
    "R_ARRAY": (function(_this) {
      return function() {
        var dt, _i, _len, _ref, _results;
        _ref = datum.r_array;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dt = _ref[_i];
          _results.push(deconstructDatum(dt, opts));
        }
        return _results;
      };
    })(this),
    "R_OBJECT": (function(_this) {
      return function() {
        var obj, pair, _i, _len, _ref;
        obj = {};
        _ref = datum.r_object;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pair = _ref[_i];
          obj[pair.key] = deconstructDatum(pair.val, opts);
        }
        return convertPseudotype(obj, opts);
      };
    })(this)
  }, (function(_this) {
    return function() {
      throw new err.RqlDriverError("Unknown Datum type");
    };
  })(this));
};

mkAtom = function(response, opts) {
  return deconstructDatum(response.response[0], opts);
};

mkSeq = function(response, opts) {
  var res, _i, _len, _ref, _results;
  _ref = response.response;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    res = _ref[_i];
    _results.push(deconstructDatum(res, opts));
  }
  return _results;
};

mkErr = function(ErrClass, response, root) {
  var bt, frame, msg;
  msg = mkAtom(response);
  bt = (function() {
    var _i, _len, _ref, _results;
    _ref = response.backtrace.frames;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      frame = _ref[_i];
      _results.push(pb.convertFrame(frame));
    }
    return _results;
  })();
  return new ErrClass(msg, root, bt);
};

module.exports.deconstructDatum = deconstructDatum;

module.exports.mkAtom = mkAtom;

module.exports.mkSeq = mkSeq;

module.exports.mkErr = mkErr;
